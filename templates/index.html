<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speakr</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        /* Dark Mode CSS Variables */
        :root {
            /* Light mode variables */
            --bg-primary: #f3f4f6; /* gray-100 */
            --bg-secondary: #ffffff; /* white */
            --bg-tertiary: #f9fafb; /* gray-50 */
            --bg-accent: #dbeafe; /* blue-100 */
            --bg-accent-hover: #bfdbfe; /* blue-200 */
            --bg-button: #2563eb; /* blue-600 */
            --bg-button-hover: #1d4ed8; /* blue-700 */
            --bg-danger: #dc2626; /* red-600 */
            --bg-danger-hover: #b91c1c; /* red-700 */
            --bg-danger-light: #fee2e2; /* red-100 */
            --bg-info-light: #dbeafe; /* blue-100 */
            --bg-warn-light: #fef3c7; /* amber-100 */
            --bg-success-light: #d1fae5; /* green-100 */
            --bg-pending-light: #f5f5f4; /* stone-100 */
            --bg-input: #ffffff; /* white */
            --bg-audio-player: linear-gradient(to right, #eff6ff, #eef2ff); /* blue-50, indigo-50 */

            --text-primary: #1f2937; /* gray-800 */
            --text-secondary: #374151; /* gray-700 */
            --text-muted: #6b7280; /* gray-500 */
            --text-light: #9ca3af; /* gray-400 */
            --text-accent: #1d4ed8; /* blue-700 */
            --text-button: #ffffff; /* white */
            --text-danger: #b91c1c; /* red-700 */
            --text-danger-strong: #991b1b; /* red-800 */
            --text-info-strong: #1e40af; /* blue-800 */
            --text-warn-strong: #92400e; /* amber-800 */
            --text-success-strong: #065f46; /* green-800 */
            --text-pending-strong: #44403c; /* stone-700 */

            --border-primary: #e5e7eb; /* gray-200 */
            --border-secondary: #d1d5db; /* gray-300 */
            --border-accent: #93c5fd; /* blue-300 */
            --border-danger: #f87171; /* red-400 */
            --border-focus: #3b82f6; /* blue-500 */
            --ring-focus: #bfdbfe; /* blue-200 */
            
            --scrollbar-track: #f1f1f1;
            --scrollbar-thumb: #c5c5c5;
            --scrollbar-thumb-hover: #a8a8a8;
        }

        .dark {
            /* Dark mode variables */
            --bg-primary: #111827; /* gray-900 */
            --bg-secondary: #1f2937; /* gray-800 */
            --bg-tertiary: #374151; /* gray-700 */
            --bg-accent: #1e3a8a; /* blue-900 */
            --bg-accent-hover: #1e40af; /* blue-800 */
            --bg-button: #2563eb; /* blue-600 */
            --bg-button-hover: #3b82f6; /* blue-500 */
            --bg-danger: #dc2626; /* red-600 */
            --bg-danger-hover: #ef4444; /* red-500 */
            --bg-danger-light: #7f1d1d; /* red-900 */
            --bg-info-light: #1e3a8a; /* blue-900 */
            --bg-warn-light: #78350f; /* amber-900 */
            --bg-success-light: #064e3b; /* green-900 */
            --bg-pending-light: #292524; /* stone-800 */
            --bg-input: #374151; /* gray-700 */
            --bg-audio-player: linear-gradient(to right, #374151, #4b5563); /* gray-700, gray-600 */

            --text-primary: #f3f4f6; /* gray-100 */
            --text-secondary: #d1d5db; /* gray-300 */
            --text-muted: #9ca3af; /* gray-400 */
            --text-light: #6b7280; /* gray-500 */
            --text-accent: #60a5fa; /* blue-400 */
            --text-button: #ffffff; /* white */
            --text-danger: #f87171; /* red-400 */
            --text-danger-strong: #fca5a5; /* red-300 */
            --text-info-strong: #93c5fd; /* blue-300 */
            --text-warn-strong: #fcd34d; /* amber-300 */
            --text-success-strong: #6ee7b7; /* green-300 */
            --text-pending-strong: #d6d3d1; /* stone-300 */

            --border-primary: #374151; /* gray-700 */
            --border-secondary: #4b5563; /* gray-600 */
            --border-accent: #1d4ed8; /* blue-700 */
            --border-danger: #ef4444; /* red-500 */
            --border-focus: #3b82f6; /* blue-500 */
            --ring-focus: #1e40af; /* blue-800 */
            
            --scrollbar-track: #2d3748; /* gray-800 */
            --scrollbar-thumb: #4a5568; /* gray-600 */
            --scrollbar-thumb-hover: #718096; /* gray-500 */
        }

        /* Modern UI styles */
        .drag-area { transition: background-color 0.3s ease, border-color 0.3s ease; }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: var(--scrollbar-track); border-radius: 12px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 12px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }
        html { /* Apply base colors to html for smoother transitions */
            background-color: var(--bg-primary); 
            color: var(--text-primary); 
            transition: background-color 0.3s, color 0.3s; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        html, body { height: 100%; margin: 0; }
        #app { min-height: 100%; display: flex; flex-direction: column; }
        main { flex-grow: 1; position: relative; }
        
        /* Sidebar styles for fixed height and independent scrolling */
        .sidebar-container {
            height: 100%; /* Match parent height */
            max-height: calc(100vh - 120px); /* Limit maximum height */
            position: sticky;
            top: 0;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent overall sidebar overflow */
        }
        
        /* Ensure the grid container has a fixed height */
        .grid-container {
            height: 100%;
            min-height: 600px; /* Minimum height to ensure content is visible */
        }
        
        .sidebar-header {
            flex-shrink: 0; /* Prevent header from shrinking */
        }
        
        .sidebar-content {
            flex-grow: 1;
            overflow-y: auto; /* Enable scrolling for content */
            padding-right: 6px; /* Space for scrollbar */
        }
        .progress-popup { position: fixed; bottom: 1rem; left: 1rem; z-index: 100; transition: all 0.3s ease-in-out; min-width: 300px; border-radius: 12px; overflow: hidden; }
        .progress-popup.minimized { transform: translateY(calc(100% - 45px)); }
        .progress-list-item { display: grid; grid-template-columns: auto 1fr auto; gap: 0.5rem; align-items: center; }
         /* Modern style for summary box */
        .summary-box {
            background-color: #f9fafb; /* bg-gray-50 */
            padding: 1rem; /* p-4 */
            border-radius: 0.75rem; /* rounded-xl */
            border: 1px solid #e5e7eb; /* border-gray-200 */
            min-height: 60px; /* min-h-[60px] or adjust as needed */
            /* max-height removed to allow full height */
            overflow-y: auto;
            white-space: pre-wrap;
            font-family: inherit; /* Use body font */
            font-size: 0.875rem; /* text-sm */
            line-height: 1.5; /* Improved line height */
            box-shadow: 0 1px 2px rgba(0,0,0,0.03); /* Subtle shadow */
        }
        
        /* Standardize border radius for all content boxes */
        .transcription-box, 
        .summary-box, 
        .chat-container,
        textarea,
        div[v-if="!editingParticipants"],
        div[v-if="!editingNotes"] {
            border-radius: 0.75rem !important; /* rounded-xl */
        }
        
        /* Ensure consistent height for tab content boxes */
        .tab-content-box {
            height: 200px !important;
            overflow-y: auto;
        }
        .chat-content-box {
            height: 650px !important;
            overflow-y: auto;
        }
        .metadata-panel {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 0.75rem; /* rounded-xl to match others */
            padding: 1rem; /* p-4 to be consistent */
            /* margin-top removed to align with other boxes */
            font-size: 0.875rem; /* text-sm */
            color: var(--text-secondary);
        }
        .metadata-panel dt {
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 0.1rem;
        }
        .metadata-panel dd {
            margin-left: 0;
            margin-bottom: 0.5rem;
            word-break: break-all; /* Wrap long filenames */
        }
         .status-badge {
             display: inline-block;
             padding: 0.15rem 0.6rem; /* Smaller padding */
             font-size: 0.65rem; /* Smaller text */
             font-weight: 500; /* font-medium */
             border-radius: 9999px; /* rounded-full */
             /* margin-top: 0.5rem; /* mt-2 */ /* Removed margin-top */
             box-shadow: 0 1px 2px rgba(0,0,0,0.05);
             letter-spacing: 0.025em;
             vertical-align: middle; /* Align with text */
             margin-left: 0.75rem; /* Add some space */
         }
         .status-processing { color: #1d4ed8; background-color: #dbeafe; } /* text-blue-800 bg-blue-100 */
         .status-summarizing { color: #92400e; background-color: #fef3c7; } /* text-amber-800 bg-amber-100 */
         .status-completed { color: #065f46; background-color: #d1fae5; } /* text-green-800 bg-green-100 */
         .status-failed { color: #991b1b; background-color: #fee2e2; } /* text-red-800 bg-red-100 */
         .status-pending { color: #57534e; background-color: #f5f5f4; } /* text-stone-700 bg-stone-100 */
         
         /* Fixed height transcription box */
         .transcription-box {
             height: 400px;
             overflow-y: auto;
             position: relative;
         }
         
         /* Modern copy button styles */
         .copy-btn {
             position: sticky;
             top: 10px;
             right: 10px;
             float: right;
             background-color: rgba(255, 255, 255, 0.9);
             border: 1px solid #e5e7eb;
             border-radius: 0.5rem;
             padding: 0.35rem 0.75rem;
             font-size: 0.75rem;
             cursor: pointer;
             z-index: 10;
             transition: all 0.2s cubic-bezier(0.25, 0.1, 0.25, 1);
             margin-bottom: 10px;
             box-shadow: 0 1px 2px rgba(0,0,0,0.05);
         }
         
         .copy-btn:hover {
             background-color: #f3f4f6;
             transform: translateY(-1px);
             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
         }
         
         /* Hover edit button styles */
         .content-box {
             position: relative;
         }
         
         .hover-edit-btn {
             position: absolute;
             top: 10px;
             right: 10px;
             background-color: rgba(255, 255, 255, 0.9);
             border: 1px solid #e5e7eb;
             border-radius: 0.5rem;
             padding: 0.35rem 0.75rem;
             font-size: 0.75rem;
             cursor: pointer;
             z-index: 10;
             transition: all 0.2s ease;
             box-shadow: 0 1px 2px rgba(0,0,0,0.05);
             opacity: 0;
         }
         
         .content-box:hover .hover-edit-btn {
             opacity: 1;
         }
         
         .hover-edit-btn:hover {
             background-color: #f3f4f6;
             transform: translateY(-1px);
             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
         }
         
         .dark .hover-edit-btn {
             background-color: rgba(55, 65, 81, 0.9);
             border-color: #4b5563;
         }
         
         .dark .hover-edit-btn:hover {
             background-color: #4b5563;
         }
         
         /* Modern chat section styles */
         .chat-container {
             border: 1px solid #e5e7eb;
             border-radius: 0.75rem;
             display: flex;
             flex-direction: column;
             height: 100%;
             box-shadow: 0 1px 3px rgba(0,0,0,0.05);
             overflow: hidden;
         }
         
         .chat-messages {
             flex-grow: 1;
             overflow-y: auto;
             padding: 1.25rem;
         }
         
         .chat-input-container {
             border-top: 1px solid #e5e7eb;
             padding: 0.75rem;
             display: flex;
             background-color: var(--bg-tertiary);
         }
         
         .message {
             margin-bottom: 1.25rem;
             max-width: 80%;
             box-shadow: 0 1px 2px rgba(0,0,0,0.05);
             line-height: 1.5;
         }
         
         .user-message {
             background-color: #dbeafe;
             border-radius: 1.25rem 1.25rem 0.25rem 1.25rem;
             padding: 0.875rem 1rem;
             margin-left: auto;
         }
         
         .ai-message {
             background-color: #f3f4f6;
             border-radius: 1.25rem 1.25rem 1.25rem 0.25rem;
             padding: 0.875rem 1rem;
         }
         
         .copyable {
             position: relative;
         }
         
         /* Markdown styling */
         .ai-message h1, .ai-message h2, .ai-message h3, 
         .summary-box h1, .summary-box h2, .summary-box h3 {
             font-weight: 600;
             margin-top: 1rem;
             margin-bottom: 0.5rem;
         }
         
         .ai-message h1, .summary-box h1 { font-size: 1.25rem; }
         .ai-message h2, .summary-box h2 { font-size: 1.15rem; }
         .ai-message h3, .summary-box h3 { font-size: 1.05rem; }
         
         .ai-message p, .summary-box p {
             margin-bottom: 0.75rem;
         }
         
         .ai-message ul, .ai-message ol,
         .summary-box ul, .summary-box ol {
             margin-left: 1.5rem;
             margin-bottom: 0.75rem;
         }
         
         .ai-message ul, .summary-box ul { list-style-type: disc; }
         .ai-message ol, .summary-box ol { list-style-type: decimal; }
         
         .ai-message code, .summary-box code {
             background-color: #f1f1f1;
             padding: 0.1rem 0.3rem;
             border-radius: 0.25rem;
             font-family: monospace;
             font-size: 0.9em;
         }
         
         .ai-message pre, .summary-box pre {
             background-color: #f1f1f1;
             padding: 0.75rem;
             border-radius: 0.25rem;
             overflow-x: auto;
             margin-bottom: 0.75rem;
         }
         
         .ai-message pre code, .summary-box pre code {
             background-color: transparent;
             padding: 0;
             border-radius: 0;
         }
         
         .ai-message table, .summary-box table {
             border-collapse: collapse;
             width: 100%;
             margin-bottom: 0.75rem;
         }
         
         .ai-message th, .ai-message td,
         .summary-box th, .summary-box td {
             border: 1px solid #ddd;
             padding: 0.5rem;
             text-align: left;
         }
         
         .ai-message th, .summary-box th {
             background-color: #f1f1f1;
             font-weight: 600;
         }
         
         .ai-message blockquote, .summary-box blockquote {
             border-left: 4px solid #ddd;
             padding-left: 1rem;
             margin-left: 0;
             margin-bottom: 0.75rem;
             color: #666;
         }
         
         /* Modern toast notification styles */
         .toast-container {
             position: fixed;
             bottom: 20px;
             right: 20px;
             z-index: 1000;
             display: flex;
             flex-direction: column;
             align-items: flex-end;
             gap: 12px;
         }
         
         .toast {
             padding: 12px 18px;
             border-radius: 8px;
             background-color: #4CAF50;
             color: white;
             font-size: 14px;
             box-shadow: 0 4px 12px rgba(0,0,0,0.1);
             opacity: 0;
             transform: translateY(20px);
             transition: all 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
             display: flex;
             align-items: center;
             min-width: 200px;
         }
         
         .toast.show {
             opacity: 1;
             transform: translateY(0);
         }
         
         .toast i {
             margin-right: 8px;
         }
         
         /* Copy button animation */
         @keyframes copy-success {
             0% { transform: scale(1); }
             50% { transform: scale(1.2); }
             100% { transform: scale(1); }
         }
         
         .copy-success {
             animation: copy-success 0.3s ease;
             color: #4CAF50 !important;
         }

    </style>
</head>
<body class="bg-[var(--bg-primary)] text-[var(--text-primary)]">
    <div id="app" class="container mx-auto px-4 sm:px-6 lg:px-8 py-6 flex flex-col">
        <header class="flex justify-between items-center mb-6 pb-4 border-b border-[var(--border-primary)]">
             <h1 class="text-3xl font-bold text-[var(--text-primary)] cursor-pointer" @click="switchToGalleryView" title="Go to Gallery">
                Speakr
            </h1>
            <div class="flex items-center space-x-2">
                 <button @click="toggleDarkMode" class="p-2 rounded-full text-[var(--text-muted)] hover:bg-[var(--bg-tertiary)] dark:text-gray-400 dark:hover:bg-gray-700 transition-colors duration-200" :title="isDarkMode ? 'Switch to Light Mode' : 'Switch to Dark Mode'">
                    <i :class="isDarkMode ? 'fas fa-sun' : 'fas fa-moon'"></i>
                </button>
                {% if current_user.is_authenticated %}
                <button @click="switchToUploadView" class="px-4 py-2 mr-2 bg-[var(--bg-button)] text-[var(--text-button)] rounded-lg shadow hover:bg-[var(--bg-button-hover)] focus:outline-none focus:ring-2 focus:ring-[var(--border-focus)] focus:ring-offset-2 transition duration-150 ease-in-out">
                    <i class="fas fa-plus mr-1"></i> New Recording
                </button>
                <button
                    @click="switchToGalleryView"
                    :class="{
                        'bg-[var(--bg-secondary)] text-[var(--text-secondary)] border border-[var(--border-secondary)]': currentView !== 'gallery',
                        'bg-[var(--bg-accent)] text-[var(--text-accent)] border border-[var(--border-accent)]': currentView === 'gallery'
                    }"
                    class="px-4 py-2 rounded-lg shadow-sm hover:bg-[var(--bg-tertiary)] focus:outline-none focus:ring-2 focus:ring-[var(--border-focus)] focus:ring-offset-1 transition duration-150 ease-in-out">
                    <i class="fas fa-images mr-1"></i> Gallery
                </button>
                <!-- User dropdown menu -->
                <div class="relative ml-2">
                    <button @click="isUserMenuOpen = !isUserMenuOpen" class="flex items-center px-3 py-2 border border-[var(--border-secondary)] rounded-lg text-[var(--text-secondary)] hover:text-[var(--text-accent)] focus:outline-none">
                        <i class="fas fa-user mr-2"></i>
                        <span>{{ current_user.username }}</span>
                        <i class="fas fa-chevron-down ml-2"></i>
                    </button>
                    <div v-if="isUserMenuOpen" class="absolute right-0 mt-2 w-48 bg-[var(--bg-secondary)] border border-[var(--border-primary)] rounded-lg shadow-lg z-10">
                        <a href="{{ url_for('account') }}" class="block px-4 py-2 text-[var(--text-secondary)] hover:bg-[var(--bg-tertiary)] hover:text-[var(--text-accent)]">
                            <i class="fas fa-user-circle mr-2"></i> Account
                        </a>
                        {% if current_user.is_admin %}
                        <a href="{{ url_for('admin') }}" class="block px-4 py-2 text-[var(--text-secondary)] hover:bg-[var(--bg-tertiary)] hover:text-[var(--text-accent)]">
                            <i class="fas fa-user-shield mr-2"></i> Admin
                        </a>
                        {% endif %}
                        <a href="{{ url_for('logout') }}" class="block px-4 py-2 text-[var(--text-secondary)] hover:bg-[var(--bg-tertiary)] hover:text-[var(--text-danger)]">
                            <i class="fas fa-sign-out-alt mr-2"></i> Logout
                        </a>
                    </div>
                </div>
                {% else %}
                <a href="{{ url_for('login') }}" class="px-4 py-2 ml-2 bg-[var(--bg-button)] text-[var(--text-button)] rounded-lg shadow hover:bg-[var(--bg-button-hover)] focus:outline-none focus:ring-2 focus:ring-[var(--border-focus)] focus:ring-offset-2 transition duration-150 ease-in-out">
                    <i class="fas fa-sign-in-alt mr-1"></i> Login
                </a>
                <a href="{{ url_for('register') }}" class="px-4 py-2 ml-2 text-[var(--text-secondary)] hover:text-[var(--text-accent)] border border-[var(--border-secondary)] rounded-lg">
                    <i class="fas fa-user-plus mr-1"></i> Register
                </a>
                {% endif %}
            </div>
        </header>

        <div v-if="globalError" class="mb-4 p-4 bg-[var(--bg-danger-light)] border border-[var(--border-danger)] text-[var(--text-danger-strong)] rounded-lg" role="alert">
             <div class="flex justify-between items-center">
                <div>
                    <strong class="font-bold">Error:</strong>
                    <span class="block sm:inline ml-2">${ globalError }</span>
                </div>
                <button @click="globalError = null" class="text-[var(--text-danger-strong)] hover:text-[var(--text-danger)] font-bold">&times;</button>
            </div>
        </div>

        <!-- Sidebar toggle button will be positioned relative to the main container -->

        <main class="flex-grow"
             @dragover.prevent="dragover = true"
             @dragleave.prevent="handleDragLeave"
             @drop.prevent="handleDrop">

            <div v-if="dragover" class="absolute inset-0 flex items-center justify-center bg-[var(--border-focus)]/20 z-10 rounded-lg pointer-events-none border-4 border-dashed border-[var(--border-focus)]">
                <div class="text-center p-6 bg-[var(--bg-secondary)] rounded-lg shadow-xl">
                    <i class="fas fa-upload text-4xl text-[var(--text-accent)] mb-3"></i>
                    <p class="text-xl font-semibold text-[var(--text-secondary)]">Drop audio file(s) here to upload</p>
                </div>
            </div>

            {% if current_user.is_authenticated %}
            <div v-if="currentView === 'gallery'" class="flex-grow flex flex-col rounded-lg relative">
                <!-- Sidebar toggle button that appears when sidebar is collapsed - positioned at the left edge of main content, aligned with title -->
                <button v-if="isSidebarCollapsed" 
                        @click="toggleSidebar" 
                        class="absolute -left-3 top-6 z-20 bg-gradient-to-r from-[var(--bg-accent)] to-[var(--bg-secondary)] p-2 pl-1 pr-3 rounded-r-lg shadow-lg text-[var(--text-accent)] hover:text-[var(--text-primary)] hover:shadow-xl transition-all duration-300 transform hover:translate-x-1 border-r border-t border-b border-[var(--border-accent)]"
                        title="Show Sidebar">
                    <i class="fas fa-chevron-right"></i>
                </button>
                
                <div class="grid grid-cols-1 lg:grid-cols-4 gap-6 flex-grow grid-container">
                    <div v-show="!isSidebarCollapsed" class="lg:col-span-1 bg-[var(--bg-secondary)] p-4 rounded-lg shadow-md sidebar-container">
                         <div class="flex justify-between items-center mb-4 sticky top-0 bg-[var(--bg-secondary)] pb-3 border-b border-[var(--border-primary)] sidebar-header">
                            <h3 class="text-lg font-semibold text-[var(--text-primary)]">Recordings</h3>
                            <button @click="toggleSidebar" class="p-1 rounded-full text-[var(--text-muted)] hover:bg-[var(--bg-tertiary)] dark:text-gray-400 dark:hover:bg-gray-700 transition-colors duration-200" :title="isSidebarCollapsed ? 'Show Sidebar' : 'Hide Sidebar'">
                                <i class="fas fa-chevron-left"></i>
                             </button>
                        </div>
                         <div v-if="isLoadingRecordings" class="text-center text-[var(--text-muted)] py-4 sidebar-content">
                            <i class="fas fa-spinner fa-spin mr-2"></i> Loading recordings...
                        </div>
                        <div v-else-if="recordings.length === 0 && uploadQueue.length === 0" class="text-center text-[var(--text-muted)] py-4 flex-grow flex flex-col items-center justify-center sidebar-content">
                             <i class="fas fa-folder-open text-4xl text-[var(--text-light)] mb-3"></i>
                            <p>No recordings yet.</p>
                            <p>Upload one or drag & drop anywhere!</p>
                        </div>
                        <div v-else class="space-y-4 custom-scrollbar sidebar-content">
                            <div v-for="group in groupedRecordings" :key="group.title" class="mb-3">
                                <h4 class="font-medium text-[var(--text-muted)] text-xs uppercase tracking-wider mb-2 sticky top-0 bg-[var(--bg-secondary)] py-1">${ group.title }</h4>
                                <ul class="space-y-1">
                                    <li v-for="recording in group.items"
                                        :key="recording.id"
                                        @click="selectRecording(recording)"
                                        class="cursor-pointer p-3 rounded-md flex justify-between items-center transition duration-150 ease-in-out"
                                        :class="{
                                            'bg-[var(--bg-accent)] hover:bg-[var(--bg-accent-hover)] ring-1 ring-[var(--border-accent)] text-[var(--text-accent)]': selectedRecording?.id === recording.id,
                                            'hover:bg-[var(--bg-tertiary)] text-[var(--text-primary)]': selectedRecording?.id !== recording.id
                                        }">
                                         <div class="flex items-center overflow-hidden mr-2">
                                            <i class="fas fa-file-audio text-[var(--text-accent)] mr-2 flex-shrink-0"></i>
                                            <span class="text-sm font-medium truncate" :title="recording.title || 'Loading title...'">${ recording.title || '(Processing...)' }</span>
                                            <span v-if="recording.is_inbox" class="ml-1 text-blue-500" title="Inbox">
                                                <i class="fas fa-inbox text-xs"></i>
                                            </span>
                                            <span v-if="recording.is_highlighted" class="ml-1 text-yellow-500" title="Highlighted">
                                                <i class="fas fa-star text-xs"></i>
                                            </span>
                                        </div>
                                        <div class="flex space-x-2 flex-shrink-0 items-center">
                                            <span v-if="recording.status === 'PROCESSING'" class="text-xs text-[var(--text-info-strong)] italic flex items-center" title="Transcribing...">
                                                 <i class="fas fa-spinner fa-spin mr-1"></i> Transcribing
                                            </span>
                                             <span v-else-if="recording.status === 'SUMMARIZING'" class="text-xs text-[var(--text-warn-strong)] italic flex items-center" title="Generating Summary...">
                                                <i class="fas fa-spinner fa-spin mr-1"></i> Summarizing
                                            </span>
                                            <span v-else-if="recording.status === 'PENDING'" class="text-xs text-[var(--text-pending-strong)] italic flex items-center" title="Waiting...">
                                                <i class="fas fa-clock mr-1"></i> Pending
                                            </span>
                                            <span v-else-if="recording.status === 'FAILED'" class="text-xs text-[var(--text-danger-strong)] italic flex items-center" title="Processing Failed">
                                                <i class="fas fa-exclamation-triangle mr-1"></i> Failed
                                            </span>
                                            <span v-else-if="recording.status === 'COMPLETED'" class="text-xs text-[var(--text-success-strong)]" title="Completed">
                                                <i class="fas fa-check-circle"></i>
                                            </span>
                                             <button @click.stop="editRecording(recording)" class="text-[var(--text-muted)] hover:text-[var(--text-accent)] text-xs p-1 rounded hover:bg-[var(--bg-tertiary)]" title="Edit Details">
                                                <i class="fas fa-edit"></i>
                                            </button>
                                            <button @click.stop="confirmDelete(recording)" class="text-[var(--text-muted)] hover:text-[var(--text-danger)] text-xs p-1 rounded hover:bg-[var(--bg-tertiary)]" title="Delete Recording">
                                                <i class="fas fa-trash"></i>
                                            </button>
                                        </div>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </div>

                     <div :class="isSidebarCollapsed ? 'lg:col-span-4' : 'lg:col-span-3'" class="bg-[var(--bg-secondary)] p-6 rounded-lg shadow-md flex flex-col">
                        <div v-if="selectedRecording" class="flex-grow flex flex-col">
                            <div class="flex flex-col sm:flex-row justify-between items-start mb-4 border-b border-[var(--border-primary)] pb-4">
                                <div class="mb-3 sm:mb-0 max-w-lg">
                                     <h3 class="text-2xl font-semibold text-[var(--text-primary)] flex items-center">
                                        ${ selectedRecording.title || 'Loading...' }
                                        <span v-if="selectedRecording.is_inbox" class="ml-2 text-blue-500" title="Inbox">
                                            <i class="fas fa-inbox"></i>
                                        </span>
                                        <span v-if="selectedRecording.is_highlighted" class="ml-2 text-yellow-500" title="Highlighted">
                                            <i class="fas fa-star"></i>
                                        </span>
                                     </h3>
                                    <p class="text-sm text-[var(--text-muted)] mt-1">
                                        <!-- Display Meeting Date with edit functionality -->
                                        <span>
                                            <i class="fas fa-calendar-alt mr-1"></i> 
                                            <span v-if="!editingMeetingDate">
                                                Meeting Date: 
                                                <span @click="toggleEditMeetingDate" class="cursor-pointer hover:text-[var(--text-accent)]">
                                                    ${ selectedRecording.meeting_date ? formatDisplayDate(selectedRecording.meeting_date) : 'Click to add' }
                                                </span> | 
                                            </span>
                                            <span v-else class="inline-flex items-center">
                                                <input type="date" v-model="selectedRecording.meeting_date" 
                                                    @blur="saveInlineEdit('meeting_date')" 
                                                    class="p-0 w-40 bg-transparent border-b border-[var(--border-secondary)] focus:outline-none focus:border-[var(--border-focus)]" />
                                                <button @click="saveInlineEdit('meeting_date')" class="ml-1 text-xs text-[var(--text-accent)]">
                                                    <i class="fas fa-check"></i>
                                                </button>
                                            </span>
                                        </span>
                                        Created: ${ new Date(selectedRecording.created_at).toLocaleString() }
                                        <!-- Status Badge Moved Here -->
                                        <span :class="getStatusClass(selectedRecording.status)" class="status-badge">
                                            ${ formatStatus(selectedRecording.status) }
                                        </span>
                                    </p>
                                    <!-- Removed Size from here -->
                                    <!-- Removed separate Status Badge span -->
                                </div>
                                <div class="flex space-x-2 flex-shrink-0">
                                    <button @click="toggleInbox(selectedRecording)" class="px-3 py-1.5 rounded-md text-sm shadow-sm" 
                                            :class="selectedRecording.is_inbox ? 'bg-blue-500 text-white hover:bg-blue-600' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'">
                                        <i class="fas fa-inbox mr-1"></i> ${selectedRecording.is_inbox ? 'Mark as Read' : 'Move to Inbox'}
                                    </button>
                                    <button @click="toggleHighlight(selectedRecording)" class="px-3 py-1.5 rounded-md text-sm shadow-sm"
                                            :class="selectedRecording.is_highlighted ? 'bg-yellow-500 text-white hover:bg-yellow-600' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'">
                                        <i class="fas fa-star mr-1"></i> ${selectedRecording.is_highlighted ? 'Remove Highlight' : 'Highlight'}
                                    </button>
                                    <button @click="editRecording(selectedRecording)" class="px-3 py-1.5 bg-[var(--bg-button)] text-[var(--text-button)] rounded-md hover:bg-[var(--bg-button-hover)] text-sm shadow-sm">
                                        <i class="fas fa-edit mr-1"></i> Edit Details
                                    </button>
                                    <button @click="confirmDelete(selectedRecording)" class="px-3 py-1.5 bg-[var(--bg-danger)] text-[var(--text-button)] rounded-md hover:bg-[var(--bg-danger-hover)] text-sm shadow-sm">
                                        <i class="fas fa-trash mr-1"></i> Delete
                                    </button>
                                </div>
                            </div>

                            <!-- Adjusted Grid: md:grid-cols-5 -> Transcription (2), Right Panel (3) -->
                            <div class="grid md:grid-cols-5 gap-6 flex-grow overflow-hidden">
                                <!-- Left Column: Participants, Transcription, Summary & Notes -->
                                <div class="md:col-span-2 flex flex-col overflow-hidden space-y-4">
                                    <div>
                                        <div class="flex justify-between items-center mb-1">
                                            <h4 class="font-semibold text-[var(--text-secondary)]">Participants</h4>
                                            <button @click="toggleEditParticipants" class="text-xs text-[var(--text-muted)] hover:text-[var(--text-accent)] p-1 rounded">
                                                <i class="fas" :class="editingParticipants ? 'fa-check' : 'fa-edit'"></i>
                                            </button>
                                        </div>
                                        <div v-if="!editingParticipants" class="text-sm bg-[var(--bg-tertiary)] p-3 rounded-xl border border-[var(--border-primary)] min-h-[40px] text-[var(--text-secondary)]">${ selectedRecording.participants || 'None specified' }</div>
                                        <textarea v-else v-model="selectedRecording.participants" @blur="saveInlineEdit('participants')" class="text-sm bg-[var(--bg-tertiary)] p-3 rounded border border-[var(--border-primary)] min-h-[40px] w-full focus:ring-[var(--ring-focus)] focus:border-[var(--border-focus)] text-[var(--text-secondary)]" placeholder="Enter participants"></textarea>
                                    </div>
                                    <div>
                                        <div class="flex justify-between items-center mb-1">
                                            <h4 class="font-semibold text-[var(--text-secondary)]">Transcription</h4>
                                            <button @click="copyTranscription($event)" class="text-xs text-[var(--text-muted)] hover:text-[var(--text-accent)] p-1 rounded" title="Copy to clipboard">
                                                <i class="fas fa-copy"></i>
                                            </button>
                                        </div>
                                        <div class="transcription-box p-4 bg-[var(--bg-tertiary)] rounded border border-[var(--border-primary)] text-sm custom-scrollbar relative text-[var(--text-secondary)]">
                                            <div v-if="selectedRecording.status === 'COMPLETED' || selectedRecording.status === 'SUMMARIZING'" class="copyable">
                                                <pre class="whitespace-pre-wrap font-sans">${ selectedRecording.transcription || 'No transcription available.' }</pre>
                                            </div>
                                            <div v-else-if="selectedRecording.status === 'FAILED'" class="text-[var(--text-danger)]">
                                                <p class="font-medium mb-2">Processing Failed:</p>
                                                <pre class="whitespace-pre-wrap font-sans">${ selectedRecording.transcription || 'An unknown error occurred.' }</pre>
                                            </div>
                                            <div v-else class="flex items-center justify-center text-[var(--text-muted)] h-full">
                                                <i class="fas fa-spinner fa-spin mr-2"></i> Transcription in progress...
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <!-- Tabs for Summary and Notes (Moved from right column) -->
                                    <div class="flex flex-col overflow-hidden">
                                        <div class="border-b border-[var(--border-primary)]">
                                            <nav class="-mb-px flex space-x-4" aria-label="Tabs">
                                                <button @click="selectedTab = 'summary'" 
                                                        :class="selectedTab === 'summary' ? 'border-[var(--border-focus)] text-[var(--text-accent)]' : 'border-transparent text-[var(--text-muted)] hover:text-[var(--text-secondary)] hover:border-[var(--border-secondary)]'"
                                                        class="whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm">
                                                    Summary
                                                </button>
                                                <button @click="selectedTab = 'notes'" 
                                                        :class="selectedTab === 'notes' ? 'border-[var(--border-focus)] text-[var(--text-accent)]' : 'border-transparent text-[var(--text-muted)] hover:text-[var(--text-secondary)] hover:border-[var(--border-secondary)]'"
                                                        class="whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm">
                                                    Notes
                                                </button>
                                                <button @click="selectedTab = 'metadata'" 
                                                        :class="selectedTab === 'metadata' ? 'border-[var(--border-focus)] text-[var(--text-accent)]' : 'border-transparent text-[var(--text-muted)] hover:text-[var(--text-secondary)] hover:border-[var(--border-secondary)]'"
                                                        class="whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm">
                                                    Metadata
                                                </button>
                                            </nav>
                                        </div>
                                        <div class="pt-4">
                                            <!-- Summary Panel -->
                                            <div v-show="selectedTab === 'summary'" class="overflow-hidden">
                                                <div v-if="selectedRecording.status === 'COMPLETED'">
                                                    <div v-if="!editingSummary" class="content-box">
                                                        <div class="summary-box custom-scrollbar bg-[var(--bg-tertiary)] border-[var(--border-primary)] text-[var(--text-secondary)] tab-content-box" v-html="selectedRecording.summary_html || selectedRecording.summary || 'No summary generated.'">
                                                        </div>
                                                        <button @click="toggleEditSummary" class="hover-edit-btn text-[var(--text-muted)] hover:text-[var(--text-accent)]" title="Edit Summary">
                                                            <i class="fas fa-edit"></i>
                                                        </button>
                                                    </div>
                                                    <textarea v-else v-model="selectedRecording.summary" @blur="saveInlineEdit('summary')" class="summary-box custom-scrollbar bg-[var(--bg-tertiary)] border-[var(--border-primary)] text-[var(--text-secondary)] w-full focus:ring-[var(--ring-focus)] focus:border-[var(--border-focus)] tab-content-box" placeholder="Enter summary"></textarea>
                                                </div>
                                                <div v-else-if="selectedRecording.status === 'FAILED'" class="summary-box text-[var(--text-danger)] custom-scrollbar bg-[var(--bg-tertiary)] border-[var(--border-primary)] tab-content-box" v-html="selectedRecording.summary_html || selectedRecording.summary || 'Summary generation failed or was skipped.'">
                                                </div>
                                                <div v-else class="h-24 flex items-center justify-center p-4 bg-[var(--bg-tertiary)] rounded border border-[var(--border-primary)] text-[var(--text-muted)]">
                                                    <i class="fas fa-spinner fa-spin mr-2"></i> Summary pending...
                                                </div>
                                                
                                            </div>
                                            
                                            <!-- Notes Panel -->
                                            <div v-show="selectedTab === 'notes'" class="overflow-hidden">
                                                <div v-if="!editingNotes" class="content-box">
                                                    <div class="text-sm bg-[var(--bg-tertiary)] p-4 rounded-xl border border-[var(--border-primary)] custom-scrollbar text-[var(--text-secondary)] tab-content-box" v-html="selectedRecording.notes_html || selectedRecording.notes || 'No notes'"></div>
                                                    <button @click="toggleEditNotes" class="hover-edit-btn text-[var(--text-muted)] hover:text-[var(--text-accent)]" title="Edit Notes">
                                                        <i class="fas fa-edit"></i>
                                                    </button>
                                                </div>
                                                <textarea v-else v-model="selectedRecording.notes" @blur="saveInlineEdit('notes')" class="text-sm bg-[var(--bg-tertiary)] p-4 rounded border border-[var(--border-primary)] custom-scrollbar text-[var(--text-secondary)] w-full focus:ring-[var(--ring-focus)] focus:border-[var(--border-focus)] tab-content-box" placeholder="Enter notes"></textarea>
                                            </div>
                                            
                                            <!-- Metadata Panel (in separate tab) -->
                                            <div v-show="selectedTab === 'metadata'" class="overflow-hidden">
                                                <div class="metadata-panel custom-scrollbar tab-content-box">
                                                    <dl>
                                                        <div v-if="selectedRecording.original_filename">
                                                            <dt>Original Filename</dt>
                                                            <dd>${ selectedRecording.original_filename }</dd>
                                                        </div>
                                                        <div>
                                                            <dt>File Size</dt>
                                                            <dd>${ formatFileSize(selectedRecording.file_size) }</dd>
                                                        </div>
                                                    </dl>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Right Column: Audio & Chat -->
                                <div class="md:col-span-3 flex flex-col space-y-4 overflow-hidden">
                                    <div>
                                        <h4 class="font-semibold text-[var(--text-secondary)] mb-2">Audio Player</h4>
                                        <!-- Beautified audio player container -->
                                        <div class="bg-[var(--bg-audio-player)] p-3 rounded-lg shadow border border-[var(--border-primary)]">
                                            <audio controls class="w-full h-10" :key="selectedRecording.id" :src="'/audio/' + selectedRecording.id">
                                                Your browser does not support the audio element.
                                            </audio>
                                        </div>
                                    </div>

                                    <!-- Chat Section (Fixed height to match left column) -->
                                    <div class="flex flex-col overflow-hidden">
                                        <h4 class="font-semibold text-[var(--text-secondary)] mb-2 flex-shrink-0">Chat with Transcript</h4>
                                        <!-- Chat container with fixed height matching left column -->
                                        <div class="chat-container border-[var(--border-primary)] bg-[var(--bg-secondary)] chat-content-box"> 
                                            <div class="chat-messages custom-scrollbar" ref="chatMessagesRef">
                                                <div v-if="chatMessages.length === 0" class="flex items-center justify-center h-full text-[var(--text-muted)]">
                                                    <div class="text-center">
                                                        <i class="fas fa-comments text-2xl mb-2"></i>
                                                        <p>Ask questions about the transcript</p>
                                                    </div>
                                                </div>
                                                <div v-for="(message, index) in chatMessages" :key="index" class="message" :class="message.role === 'user' ? 'user-message bg-[var(--bg-accent)] text-[var(--text-accent)]' : 'ai-message bg-[var(--bg-tertiary)] text-[var(--text-secondary)]'">
                                                    <div class="flex justify-between items-start">
                                                        <div class="flex-grow" v-if="message.role === 'user'">${ message.content }</div>
                                                        <div class="flex-grow" v-else v-html="message.html || message.content"></div>
                                                        <button v-if="message.role === 'assistant'" @click="copyMessage(message.content, $event)" class="ml-2 text-[var(--text-light)] hover:text-[var(--text-muted)]" title="Copy response">
                                                            <i class="fas fa-copy text-xs"></i>
                                                        </button>
                                                    </div>
                                                </div>
                                                <div v-if="isChatLoading" class="message ai-message bg-[var(--bg-tertiary)] text-[var(--text-secondary)]">
                                                    <div class="flex items-center">
                                                        <i class="fas fa-spinner fa-spin mr-2"></i> Thinking...
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="chat-input-container border-t-[var(--border-primary)]">
                                                <input 
                                                    v-model="chatInput" 
                                                    @keyup.enter="sendChatMessage"
                                                    type="text" 
                                                    placeholder="Ask about the transcript..." 
                                                    class="flex-grow px-3 py-2 border-0 focus:ring-0 focus:outline-none bg-[var(--bg-input)] text-[var(--text-primary)] placeholder-[var(--text-muted)]"
                                                    :disabled="isChatLoading || !selectedRecording || selectedRecording.status !== 'COMPLETED'"
                                                >
                                                <button 
                                                    @click="sendChatMessage" 
                                                    class="px-4 py-2 bg-[var(--bg-button)] text-[var(--text-button)] rounded-md hover:bg-[var(--bg-button-hover)] disabled:bg-[var(--bg-tertiary)] disabled:text-[var(--text-muted)] disabled:cursor-not-allowed"
                                                    :disabled="!chatInput.trim() || isChatLoading || !selectedRecording || selectedRecording.status !== 'COMPLETED'"
                                                >
                                                    <i class="fas fa-paper-plane"></i>
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div v-else class="flex flex-col items-center justify-center text-center text-[var(--text-muted)] flex-grow">
                             <i class="fas fa-hand-pointer text-4xl text-[var(--text-light)] mb-4"></i>
                            <p class="text-lg font-medium mb-2">Select a recording from the list to view details.</p>
                            <p>Or, drag and drop audio file(s) anywhere on this page to upload.</p>
                        </div>
                    </div>
                </div>
            </div>

             <div v-if="currentView === 'upload'"
                 class="flex-grow flex items-center justify-center p-4">
                 <div class="w-full max-w-lg bg-[var(--bg-secondary)] p-8 rounded-xl shadow-lg border border-[var(--border-primary)] text-center drag-area"
                     :class="{'border-[var(--border-focus)] bg-[var(--bg-accent)]': dragover}">
                    <div class="py-8">
                        <i class="fas fa-cloud-upload-alt text-5xl mb-5 text-[var(--text-accent)]"></i>
                         <h2 class="text-xl font-semibold text-[var(--text-secondary)] mb-2">Upload New Recordings</h2>
                        <p class="text-[var(--text-muted)] mb-4">Drag & drop your audio files here or click below.</p>
                         <input type="file" @change="handleFileSelect" accept="audio/*" class="hidden" ref="fileInput" multiple>
                        <button @click="$refs.fileInput.click()" class="mt-4 px-6 py-2 bg-[var(--bg-button)] text-[var(--text-button)] rounded-lg hover:bg-[var(--bg-button-hover)] shadow-sm transition duration-150 ease-in-out">
                            <i class="fas fa-file-import mr-2"></i> Select Files
                        </button>
                         <p class="text-xs text-[var(--text-light)] mt-4">Max file size per file: ${ maxFileSizeMB } MB</p>
                    </div>
                </div>
            </div>

            {% else %}
            <div class="flex-grow flex items-center justify-center">
                <div class="text-center max-w-lg p-8 bg-[var(--bg-secondary)] rounded-xl shadow-lg border border-[var(--border-primary)]">
                    <i class="fas fa-lock text-5xl mb-4 text-[var(--text-accent)]"></i>
                    <h2 class="text-2xl font-semibold text-[var(--text-primary)] mb-4">Welcome to Speakr</h2>
                    <p class="text-[var(--text-secondary)] mb-6">
                        Speakr is an audio transcription and summarization app that helps you convert your audio recordings into text and generate summaries.
                    </p>
                    <div class="flex flex-col sm:flex-row justify-center space-y-3 sm:space-y-0 sm:space-x-4">
                        <a href="{{ url_for('login') }}" class="px-6 py-2 bg-[var(--bg-button)] text-[var(--text-button)] rounded-lg shadow hover:bg-[var(--bg-button-hover)] focus:outline-none focus:ring-2 focus:ring-[var(--border-focus)] focus:ring-offset-2 transition duration-150 ease-in-out">
                            <i class="fas fa-sign-in-alt mr-2"></i> Login
                        </a>
                        <a href="{{ url_for('register') }}" class="px-6 py-2 text-[var(--text-secondary)] hover:text-[var(--text-accent)] border border-[var(--border-secondary)] rounded-lg">
                            <i class="fas fa-user-plus mr-2"></i> Register
                        </a>
                    </div>
                </div>
            </div>
            {% endif %}
            </main>

        <footer class="text-center py-4 mt-8 text-xs text-[var(--text-light)] border-t border-[var(--border-primary)]">
            Speakr &copy; ${ new Date().getFullYear() }
        </footer>

         <div v-if="showEditModal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4">
             <div class="bg-[var(--bg-secondary)] p-6 rounded-lg shadow-xl w-full max-w-lg max-h-[90vh] overflow-y-auto custom-scrollbar">
                 <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-semibold text-[var(--text-primary)]">Edit Recording Details</h3>
                    <button @click="cancelEdit" class="text-[var(--text-light)] hover:text-[var(--text-muted)] text-2xl leading-none">&times;</button>
                </div>
                <div v-if="editingRecording" class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium text-[var(--text-secondary)] mb-1">Title</label>
                        <input v-model="editingRecording.title" class="mt-1 block w-full rounded-md border-[var(--border-secondary)] shadow-sm focus:border-[var(--border-focus)] focus:ring-[var(--ring-focus)] focus:ring-opacity-50 bg-[var(--bg-input)] text-[var(--text-primary)]">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-[var(--text-secondary)] mb-1">Participants</label>
                        <input v-model="editingRecording.participants" class="mt-1 block w-full rounded-md border-[var(--border-secondary)] shadow-sm focus:border-[var(--border-focus)] focus:ring-[var(--ring-focus)] focus:ring-opacity-50 bg-[var(--bg-input)] text-[var(--text-primary)]">
                    </div>
                    <!-- Add Meeting Date Input -->
                    <div>
                        <label class="block text-sm font-medium text-[var(--text-secondary)] mb-1">Meeting Date</label>
                        <input type="date" v-model="editingRecording.meeting_date" class="mt-1 block w-full rounded-md border-[var(--border-secondary)] shadow-sm focus:border-[var(--border-focus)] focus:ring-[var(--ring-focus)] focus:ring-opacity-50 bg-[var(--bg-input)] text-[var(--text-primary)]">
                    </div>
                     <div>
                        <label class="block text-sm font-medium text-[var(--text-secondary)] mb-1">Summary</label>
                        <textarea v-model="editingRecording.summary" class="mt-1 block w-full rounded-md border-[var(--border-secondary)] shadow-sm focus:border-[var(--border-focus)] focus:ring-[var(--ring-focus)] focus:ring-opacity-50 bg-[var(--bg-input)] text-[var(--text-primary)]" rows="5"></textarea>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-[var(--text-secondary)] mb-1">Notes</label>
                        <textarea v-model="editingRecording.notes" class="mt-1 block w-full rounded-md border-[var(--border-secondary)] shadow-sm focus:border-[var(--border-focus)] focus:ring-[var(--ring-focus)] focus:ring-opacity-50 bg-[var(--bg-input)] text-[var(--text-primary)]" rows="4"></textarea>
                    </div>
                    <div class="flex justify-end space-x-3 pt-4">
                        <button @click="cancelEdit" class="px-4 py-2 bg-[var(--bg-tertiary)] text-[var(--text-secondary)] rounded-md hover:bg-[var(--border-secondary)]">Cancel</button>
                        <button @click="saveEdit" class="px-4 py-2 bg-[var(--bg-button)] text-[var(--text-button)] rounded-md hover:bg-[var(--bg-button-hover)]">Save Changes</button>
                    </div>
                </div>
            </div>
        </div>

        <div v-if="showDeleteModal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4">
             <div class="bg-[var(--bg-secondary)] p-6 rounded-lg shadow-xl max-w-md w-full">
                <h3 class="text-lg font-semibold text-[var(--text-primary)] mb-4">Confirm Delete</h3>
                 <p v-if="recordingToDelete" class="mb-2 text-[var(--text-secondary)]">Are you sure you want to permanently delete the recording titled "<strong>${ recordingToDelete.title }</strong>"?</p>
                <p class="text-sm text-[var(--text-danger)] mb-6">This action cannot be undone and will delete the record, transcription, summary, and the audio file.</p>
                <div class="flex justify-end space-x-3">
                    <button @click="cancelDelete" class="px-4 py-2 bg-[var(--bg-tertiary)] text-[var(--text-secondary)] rounded-md hover:bg-[var(--border-secondary)]">Cancel</button>
                    <button @click="deleteRecording" class="px-4 py-2 bg-[var(--bg-danger)] text-[var(--text-button)] rounded-md hover:bg-[var(--bg-danger-hover)]">Delete Permanently</button>
                </div>
            </div>
        </div>

        <div v-if="(uploadQueue.length > 0 || currentlyProcessingFile) && !progressPopupClosed"
             class="progress-popup bg-[var(--bg-secondary)] rounded-lg shadow-xl border border-[var(--border-primary)] overflow-hidden"
             :class="{ 'minimized': progressPopupMinimized }">

            <div class="flex justify-between items-center p-2 bg-[var(--bg-tertiary)] border-b border-[var(--border-primary)]">
                <h4 class="text-sm font-semibold text-[var(--text-secondary)] cursor-pointer" @click="progressPopupMinimized = !progressPopupMinimized">
                    <i class="fas fa-upload mr-2 text-[var(--text-accent)]"></i>
                    Upload & Process Progress (${ completedInQueue }/${ totalInQueue } completed)
                </h4>
                <div class="flex items-center">
                    <button class="text-[var(--text-muted)] hover:text-[var(--text-secondary)] mr-2" @click="progressPopupMinimized = !progressPopupMinimized">
                        <i :class="progressPopupMinimized ? 'fa-chevron-up' : 'fa-chevron-down'" class="fas fa-fw"></i>
                    </button>
                    <button class="text-[var(--text-muted)] hover:text-[var(--text-danger)]" @click="progressPopupClosed = true" title="Close">
                        <i class="fas fa-times fa-fw"></i>
                    </button>
                </div>
            </div>

             <div class="p-3 max-h-60 overflow-y-auto custom-scrollbar" v-show="!progressPopupMinimized">
                 <div v-if="currentlyProcessingFile" class="mb-3 pb-3 border-b border-dashed border-[var(--border-secondary)]">
                    <div class="flex items-center justify-between mb-1">
                        <p class="text-xs font-medium text-[var(--text-primary)] truncate mr-2" :title="currentlyProcessingFile.file.name">
                            <i class="fas fa-spinner fa-spin text-[var(--text-accent)] mr-1"></i> Processing: ${ currentlyProcessingFile.file.name }
                        </p>
                        <span class="text-xs text-[var(--text-muted)] flex-shrink-0">${ formatFileSize(currentlyProcessingFile.file.size) }</span>
                    </div>
                     <p class="text-xs text-[var(--text-secondary)] mb-1 italic">${ processingMessage }</p>
                    <div class="w-full bg-[var(--border-primary)] rounded-full h-1.5">
                         <div class="bg-[var(--text-accent)] h-1.5 rounded-full transition-all duration-300" :style="{ width: processingProgress + '%' }"></div>
                    </div>
                </div>

                 <div v-if="queuedFiles.length > 0" class="mb-2">
                    <p class="text-xs font-semibold text-[var(--text-muted)] mb-1">${ queuedFiles.length } file(s) queued:</p>
                    <ul class="space-y-1">
                        <li v-for="item in queuedFiles" :key="item.clientId" class="text-xs text-[var(--text-secondary)] progress-list-item">
                            <i class="fas fa-clock text-[var(--text-light)] fa-fw"></i>
                            <span class="truncate" :title="item.file.name">${ item.file.name }</span>
                            <span class="text-[var(--text-light)] flex-shrink-0">${ formatFileSize(item.file.size) }</span>
                        </li>
                    </ul>
                </div>

                <div v-if="finishedFilesInQueue.length > 0" class="mt-2 pt-2 border-t border-dashed border-[var(--border-secondary)]">
                    <p class="text-xs font-semibold text-[var(--text-muted)] mb-1">Recently finished:</p>
                    <ul class="space-y-1">
                         <li v-for="item in finishedFilesInQueue.slice(-5)" :key="item.clientId" class="text-xs progress-list-item">
                             <i v-if="item.status === 'completed'" class="fas fa-check-circle text-[var(--text-success-strong)] fa-fw"></i>
                            <i v-else-if="item.status === 'failed'" class="fas fa-exclamation-triangle text-[var(--text-danger-strong)] fa-fw"></i>
                             <i v-else class="fas fa-question-circle text-[var(--text-light)] fa-fw"></i>
                            <span class="truncate text-[var(--text-secondary)]" :title="item.file.name">${ item.file.name }</span>
                             <span v-if="item.status === 'failed'" class="text-[var(--text-danger)] text-xs italic flex-shrink-0">Failed</span>
                            <span v-else class="text-[var(--text-light)] flex-shrink-0">${ formatFileSize(item.file.size) }</span>
                        </li>
                    </ul>
                </div>

                 <div v-if="uploadQueue.length > 0 && queuedFiles.length === 0 && !currentlyProcessingFile" class="text-xs text-center text-[var(--text-muted)] py-2">
                    All uploads processed.
                </div>
            </div>
        </div>

    </div>
    
    <!-- Toast container for notifications -->
    <div class="toast-container" id="toastContainer"></div>
    
    {% raw %}
    <script>
        const { createApp, ref, reactive, computed, onMounted, watch, nextTick } = Vue

        createApp({
            setup() {
                const currentView = ref('gallery');
                const dragover = ref(false);
                const recordings = ref([]);
                const selectedRecording = ref(null);
                const selectedTab = ref('summary'); // For Summary/Notes tabs

                // --- Multi-Upload State ---
                // Status: 'queued'|'uploading'|'processing'|'summarizing'|'completed'|'failed'
                const uploadQueue = ref([]);
                const currentlyProcessingFile = ref(null);
                const processingProgress = ref(0);
                const processingMessage = ref('');
                const isProcessingActive = ref(false);
                const pollInterval = ref(null);
                const progressPopupMinimized = ref(false);
                const progressPopupClosed = ref(false);

                const showEditModal = ref(false);
                const showDeleteModal = ref(false);
                const editingRecording = ref(null); // Holds a *copy* for the modal
                const recordingToDelete = ref(null);
                // const autoSaveTimeout = ref(null); // Autosave not implemented for modal
                const isLoadingRecordings = ref(true);
                const globalError = ref(null);
                const maxFileSizeMB = ref(250); // Default, could fetch from config if needed
                const isDarkMode = ref(false); // Dark mode state
                const isSidebarCollapsed = ref(false); // Sidebar state
                const isUserMenuOpen = ref(false); // User dropdown menu state
                
                // Inline editing state
                const editingParticipants = ref(false);
                const editingMeetingDate = ref(false);
                const editingSummary = ref(false);
                const editingNotes = ref(false);

                // --- Computed Properties ---
                const groupedRecordings = computed(() => {
                    const sortedRecordings = [...recordings.value].sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                    // Grouping logic (same as before)...
                    const groups = { today: [], yesterday: [], thisWeek: [], older: [] };
                    const now = new Date();
                    const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    const yesterdayStart = new Date(todayStart);
                    yesterdayStart.setDate(todayStart.getDate() - 1);
                    const currentDayOfWeek = now.getDay();
                    const daysToSubtract = currentDayOfWeek === 0 ? 6 : currentDayOfWeek - 1;
                    const weekStart = new Date(todayStart);
                    weekStart.setDate(todayStart.getDate() - daysToSubtract);

                    sortedRecordings.forEach(r => {
                         const date = new Date(r.created_at);
                        if (date >= todayStart) groups.today.push(r);
                        else if (date >= yesterdayStart) groups.yesterday.push(r);
                        else if (date >= weekStart) groups.thisWeek.push(r);
                        else groups.older.push(r);
                    });
                     return [
                        { title: 'Today', items: groups.today },
                        { title: 'Yesterday', items: groups.yesterday },
                        { title: 'This Week', items: groups.thisWeek },
                        { title: 'Older', items: groups.older }
                    ].filter(g => g.items.length > 0);
                });

                 const totalInQueue = computed(() => uploadQueue.value.length);
                const completedInQueue = computed(() => uploadQueue.value.filter(item => item.status === 'completed' || item.status === 'failed').length);
                const queuedFiles = computed(() => uploadQueue.value.filter(item => item.status === 'queued'));
                // Filter finished: includes completed and failed
                 const finishedFilesInQueue = computed(() => uploadQueue.value.filter(item => ['completed', 'failed'].includes(item.status)));


                // --- Methods ---
                const setGlobalError = (message, duration = 7000) => {
                     globalError.value = message;
                     if (duration > 0) {
                        setTimeout(() => { if (globalError.value === message) globalError.value = null; }, duration);
                    }
                };

                 const formatFileSize = (bytes) => {
                     if (bytes == null || bytes === 0) return '0 Bytes';
                    const k = 1024;
                    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                     if (bytes < 0) bytes = 0;
                    const i = bytes === 0 ? 0 : Math.max(0, Math.floor(Math.log(bytes) / Math.log(k)));
                     const size = i === 0 ? bytes : parseFloat((bytes / Math.pow(k, i)).toFixed(2));
                    return size + ' ' + sizes[i];
                };

                // --- Dark Mode ---
                const toggleDarkMode = () => {
                    isDarkMode.value = !isDarkMode.value;
                    if (isDarkMode.value) {
                        document.documentElement.classList.add('dark');
                        localStorage.setItem('darkMode', 'true');
                    } else {
                        document.documentElement.classList.remove('dark');
                        localStorage.setItem('darkMode', 'false');
                    }
                };

                const initializeDarkMode = () => {
                    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                    const savedMode = localStorage.getItem('darkMode');
                    if (savedMode === 'true' || (savedMode === null && prefersDark)) {
                        isDarkMode.value = true;
                        document.documentElement.classList.add('dark');
                    } else {
                        isDarkMode.value = false;
                        document.documentElement.classList.remove('dark');
                    }
                };
                // --- End Dark Mode ---

                // --- Sidebar Toggle ---
                const toggleSidebar = () => {
                    isSidebarCollapsed.value = !isSidebarCollapsed.value;
                    // Optional: Save state to localStorage if persistence is desired
                    // localStorage.setItem('sidebarCollapsed', isSidebarCollapsed.value);
                };
                // --- End Sidebar Toggle ---
                
                // Helper to format date for display (e.g., "May 4, 2025")
                const formatDisplayDate = (dateString) => {
                    if (!dateString) return '';
                    try {
                        // Input is expected as 'YYYY-MM-DD'
                        const date = new Date(dateString + 'T00:00:00'); // Add time to avoid timezone issues
                        return date.toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' });
                    } catch (e) {
                        console.error("Error formatting date:", e);
                        return dateString; // Return original string if formatting fails
                    }
                };

                // Helper for status display
                 const formatStatus = (status) => {
                     if (!status) return 'Unknown';
                     // Capitalize first letter, handle 'SUMMARIZING' specifically
                     return status.charAt(0).toUpperCase() + status.slice(1).toLowerCase();
                };

                // Helper for status badge class
                const getStatusClass = (status) => {
                    switch(status) {
                        case 'PENDING': return 'status-pending';
                        case 'PROCESSING': return 'status-processing';
                        case 'SUMMARIZING': return 'status-summarizing';
                        case 'COMPLETED': return 'status-completed';
                        case 'FAILED': return 'status-failed';
                        default: return 'status-pending'; // Default or unknown
                    }
                };


                const resetCurrentFileProcessingState = () => {
                    if (pollInterval.value) clearInterval(pollInterval.value);
                    pollInterval.value = null;
                    currentlyProcessingFile.value = null;
                    processingProgress.value = 0;
                    processingMessage.value = '';
                };

                const switchToUploadView = () => {
                    currentView.value = 'upload';
                    selectedRecording.value = null;
                 };

                const switchToGalleryView = async () => {
                    currentView.value = 'gallery';
                     await loadRecordings(); // Refresh recordings when switching back
                };

                const handleDragLeave = (e) => {
                    if (e.relatedTarget && e.currentTarget.contains(e.relatedTarget)) {
                         return;
                    }
                    dragover.value = false;
                }

                const handleDrop = (e) => {
                    dragover.value = false;
                    addFilesToQueue(e.dataTransfer.files);
                 };

                const handleFileSelect = (e) => {
                    addFilesToQueue(e.target.files);
                    e.target.value = null; // Reset input
                };

                // --- Queue Management ---
                const addFilesToQueue = (files) => {
                    let filesAdded = 0;
                    for (const file of files) {
                        if (file && file.type.startsWith('audio/')) {
                             if (file.size > maxFileSizeMB.value * 1024 * 1024) {
                                setGlobalError(`File "${file.name}" exceeds the maximum size of ${maxFileSizeMB.value} MB and was skipped.`);
                                continue;
                            }
                             const clientId = `client-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
                            uploadQueue.value.push({
                                file: file, status: 'queued', recordingId: null, clientId: clientId, error: null
                            });
                            filesAdded++;
                        } else if (file) {
                            setGlobalError(`Invalid file type "${file.name}". Only audio files are accepted. File skipped.`);
                        }
                    }
                     if(filesAdded > 0) {
                        console.log(`Added ${filesAdded} file(s) to the queue.`);
                        progressPopupMinimized.value = false; // Show popup
                        progressPopupClosed.value = false; // Reset closed state to make popup reappear
                        if (!isProcessingActive.value) {
                            startProcessingQueue();
                        }
                    }
                };

                 const startProcessingQueue = async () => {
                    console.log("Attempting to start processing queue...");
                    if (isProcessingActive.value) {
                        console.log("Queue processor already active.");
                        return;
                    }

                    isProcessingActive.value = true;
                    resetCurrentFileProcessingState();

                     const nextFileItem = uploadQueue.value.find(item => item.status === 'queued');

                    if (nextFileItem) {
                        console.log(`Processing next file: ${nextFileItem.file.name} (Client ID: ${nextFileItem.clientId})`);
                        currentlyProcessingFile.value = nextFileItem;
                        nextFileItem.status = 'uploading';
                        processingMessage.value = 'Preparing upload...';
                        processingProgress.value = 5;

                        try {
                            const formData = new FormData();
                            formData.append('file', nextFileItem.file);

                            processingMessage.value = 'Uploading file...';
                            processingProgress.value = 10;

                            const response = await fetch('/upload', { method: 'POST', body: formData });
                            const data = await response.json();

                            if (!response.ok) {
                                let errorMsg = data.error || `Upload failed with status ${response.status}`;
                                if (response.status === 413) errorMsg = data.error || `File too large. Max: ${data.max_size_mb?.toFixed(0) || maxFileSizeMB.value} MB.`;
                                throw new Error(errorMsg);
                            }

                             if (response.status === 202 && data.id) {
                                console.log(`File ${nextFileItem.file.name} uploaded. Recording ID: ${data.id}. Starting status poll.`);
                                // Status is now 'PENDING' on backend, will be updated by poll
                                nextFileItem.status = 'pending'; // Reflect initial backend status
                                nextFileItem.recordingId = data.id;
                                processingMessage.value = 'Upload complete. Waiting for processing...';
                                processingProgress.value = 30;

                                 // Add preliminary record to gallery immediately
                                recordings.value.unshift(data);
                                // Optionally select the new item
                                // selectRecording(data);

                                pollProcessingStatus(nextFileItem); // Start polling

                            } else {
                                throw new Error('Unexpected success response from server after upload.');
                            }

                        } catch (error) {
                            console.error(`Upload/Processing Error for ${nextFileItem.file.name} (Client ID: ${nextFileItem.clientId}):`, error);
                            nextFileItem.status = 'failed';
                            nextFileItem.error = error.message;
                             // Find the potentially added preliminary record and mark it failed
                             const failedRecordIndex = recordings.value.findIndex(r => r.id === nextFileItem.recordingId);
                             if(failedRecordIndex !== -1) {
                                recordings.value[failedRecordIndex].status = 'FAILED';
                                recordings.value[failedRecordIndex].transcription = `Upload/Processing failed: ${error.message}`;
                             } else {
                                // If record wasn't even created, add a note
                                setGlobalError(`Failed to process "${nextFileItem.file.name}": ${error.message}`);
                             }

                             // Reset state and try next file
                             resetCurrentFileProcessingState();
                             isProcessingActive.value = false;
                             await nextTick();
                             startProcessingQueue();
                         }
                    } else {
                        console.log("Upload queue is empty or no files are queued.");
                        isProcessingActive.value = false;
                        // Optional: Auto-minimize popup after a delay
                         // setTimeout(() => {
                        //     if (!isProcessingActive.value && uploadQueue.value.every(f => ['completed', 'failed'].includes(f.status))) {
                         //         progressPopupMinimized.value = true;
                        //     }
                         // }, 5000);
                    }
                };

                const pollProcessingStatus = (fileItem) => {
                     if (pollInterval.value) clearInterval(pollInterval.value);

                    const recordingId = fileItem.recordingId;
                    if (!recordingId) {
                        console.error("Cannot poll status without recording ID for", fileItem.file.name);
                        fileItem.status = 'failed';
                        fileItem.error = 'Internal error: Missing recording ID for polling.';
                        resetCurrentFileProcessingState();
                        isProcessingActive.value = false;
                        nextTick(startProcessingQueue); // Try next file
                        return;
                    }

                    // Initial message based on fileItem status (should be 'pending' initially)
                    processingMessage.value = 'Waiting for transcription...';
                    processingProgress.value = 40;

                    pollInterval.value = setInterval(async () => {
                        // Check if the item is still the one being processed and hasn't finished/failed
                         if (!currentlyProcessingFile.value || currentlyProcessingFile.value.clientId !== fileItem.clientId || ['completed', 'failed'].includes(fileItem.status)) {
                             console.log(`Polling stopped for ${fileItem.clientId} as it's no longer active or finished.`);
                            clearInterval(pollInterval.value);
                            pollInterval.value = null;
                             // If this was the active file, allow queue to restart
                            if (currentlyProcessingFile.value && currentlyProcessingFile.value.clientId === fileItem.clientId) {
                                resetCurrentFileProcessingState();
                                isProcessingActive.value = false;
                                await nextTick();
                                startProcessingQueue();
                            }
                            return;
                        }

                        try {
                            console.log(`Polling status for recording ID: ${recordingId} (${fileItem.file.name})`);
                            const response = await fetch(`/status/${recordingId}`);
                            if (!response.ok) throw new Error(`Status check failed with status ${response.status}`);

                            const data = await response.json();
                             const galleryIndex = recordings.value.findIndex(r => r.id === recordingId);

                            // Update item in the main recordings list
                            if (galleryIndex !== -1) {
                                recordings.value[galleryIndex] = data;
                                if(selectedRecording.value?.id === recordingId) {
                                    selectedRecording.value = data; // Update selection if viewing details
                                }
                            }

                            // Update the status in the uploadQueue item as well
                            fileItem.status = data.status;

                            // Update progress display based on backend status
                            if (data.status === 'COMPLETED') {
                                console.log(`Processing COMPLETED for ${fileItem.file.name} (ID: ${recordingId})`);
                                processingMessage.value = 'Processing complete!';
                                processingProgress.value = 100;
                                fileItem.status = 'completed'; // Final status for queue item
                                // Stop polling, reset state, and trigger next item
                                clearInterval(pollInterval.value);
                                pollInterval.value = null;
                                resetCurrentFileProcessingState();
                                isProcessingActive.value = false;
                                await nextTick();
                                startProcessingQueue();

                            } else if (data.status === 'FAILED') {
                                console.log(`Processing FAILED for ${fileItem.file.name} (ID: ${recordingId})`);
                                processingMessage.value = 'Processing failed.';
                                processingProgress.value = 100; // Show 100% but failed state
                                fileItem.status = 'failed'; // Final status for queue item
                                fileItem.error = data.transcription || data.summary || 'Processing failed on server.';
                                setGlobalError(`Processing failed for "${data.title || fileItem.file.name}".`);
                                // Stop polling, reset state, and trigger next item
                                clearInterval(pollInterval.value);
                                pollInterval.value = null;
                                resetCurrentFileProcessingState();
                                isProcessingActive.value = false;
                                await nextTick();
                                startProcessingQueue();

                            } else if (data.status === 'PROCESSING') {
                                processingMessage.value = 'Transcription in progress...';
                                processingProgress.value = Math.min(65, processingProgress.value + Math.random() * 5); // Mid-range progress
                            } else if (data.status === 'SUMMARIZING') {
                                processingMessage.value = 'Generating title & summary...';
                                processingProgress.value = Math.min(95, processingProgress.value + Math.random() * 5); // Higher progress
                            } else { // PENDING
                                processingMessage.value = 'Waiting in queue...';
                                processingProgress.value = 45; // Keep progress indication while pending
                            }
                        } catch (error) {
                            console.error(`Polling Error for ${fileItem.file.name} (ID: ${recordingId}):`, error);
                             // Assume failed if polling error occurs
                            fileItem.status = 'failed';
                            fileItem.error = `Error checking status: ${error.message}`;
                            setGlobalError(`Error checking status for "${fileItem.file.name}": ${error.message}.`);
                             // Update record in gallery if found
                             const galleryIndex = recordings.value.findIndex(r => r.id === recordingId);
                            if (galleryIndex !== -1) recordings.value[galleryIndex].status = 'FAILED';

                            clearInterval(pollInterval.value);
                            pollInterval.value = null;
                            resetCurrentFileProcessingState();
                            isProcessingActive.value = false;
                            await nextTick();
                            startProcessingQueue(); // Process the next file
                        }
                    }, 5000); // Poll every 5 seconds (adjust as needed)
                };

                // --- Gallery and Detail Methods ---
                // AutoSave removed in favor of explicit save in modal
                // const autoSave = () => { ... };

                // Toggle inbox status
                const toggleInbox = async (recording) => {
                    if (!recording || !recording.id) return;
                    
                    try {
                        const response = await fetch(`/recording/${recording.id}/toggle_inbox`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' }
                        });
                        
                        const data = await response.json();
                        if (!response.ok) throw new Error(data.error || 'Failed to toggle inbox status');
                        
                        // Update the recording in the UI
                        recording.is_inbox = data.is_inbox;
                        
                        // Update in the recordings list
                        const index = recordings.value.findIndex(r => r.id === recording.id);
                        if (index !== -1) {
                            recordings.value[index].is_inbox = data.is_inbox;
                        }
                        
                        showToast(`Recording ${data.is_inbox ? 'moved to inbox' : 'marked as read'}`);
                    } catch (error) {
                        console.error('Toggle Inbox Error:', error);
                        setGlobalError(`Failed to toggle inbox status: ${error.message}`);
                    }
                };
                
                // Toggle highlighted status
                const toggleHighlight = async (recording) => {
                    if (!recording || !recording.id) return;
                    
                    try {
                        const response = await fetch(`/recording/${recording.id}/toggle_highlight`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' }
                        });
                        
                        const data = await response.json();
                        if (!response.ok) throw new Error(data.error || 'Failed to toggle highlighted status');
                        
                        // Update the recording in the UI
                        recording.is_highlighted = data.is_highlighted;
                        
                        // Update in the recordings list
                        const index = recordings.value.findIndex(r => r.id === recording.id);
                        if (index !== -1) {
                            recordings.value[index].is_highlighted = data.is_highlighted;
                        }
                        
                        showToast(`Recording ${data.is_highlighted ? 'highlighted' : 'unhighlighted'}`);
                    } catch (error) {
                        console.error('Toggle Highlight Error:', error);
                        setGlobalError(`Failed to toggle highlighted status: ${error.message}`);
                    }
                };

                 const saveMetadata = async (recordingDataToSave) => {
                    globalError.value = null;
                    if (!recordingDataToSave || !recordingDataToSave.id) return null;
                    console.log('Saving metadata for:', recordingDataToSave.id);
                    try {
                        const payload = {
                            id: recordingDataToSave.id,
                            title: recordingDataToSave.title,
                            participants: recordingDataToSave.participants,
                            notes: recordingDataToSave.notes,
                            summary: recordingDataToSave.summary, // <-- ADDED: Include summary
                            meeting_date: recordingDataToSave.meeting_date // <-- ADDED: Include meeting_date (should be YYYY-MM-DD)
                        };
                        const response = await fetch('/save', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        const data = await response.json();
                        if (!response.ok) throw new Error(data.error || 'Failed to save metadata');

                        console.log('Save successful:', data.recording.id);
                        // Update the master recordings list
                        const index = recordings.value.findIndex(r => r.id === data.recording.id);
                        if (index !== -1) {
                            // Update only the editable fields, preserve others like status/transcription from backend
                             recordings.value[index].title = payload.title;
                             recordings.value[index].participants = payload.participants;
                             recordings.value[index].notes = payload.notes;
                             recordings.value[index].notes_html = data.recording.notes_html;
                             recordings.value[index].summary = payload.summary;
                             recordings.value[index].summary_html = data.recording.summary_html;
                             recordings.value[index].meeting_date = payload.meeting_date; // <-- ADDED: Update meeting_date
                         }
                         // Update selected if it's the one being saved
                         if (selectedRecording.value?.id === data.recording.id) {
                            selectedRecording.value.title = payload.title;
                            selectedRecording.value.participants = payload.participants;
                            selectedRecording.value.notes = payload.notes;
                            selectedRecording.value.notes_html = data.recording.notes_html;
                            selectedRecording.value.summary = payload.summary;
                            selectedRecording.value.summary_html = data.recording.summary_html;
                            selectedRecording.value.meeting_date = payload.meeting_date; // <-- ADDED: Update meeting_date
                         }
                        return data.recording; // Return the full updated object from backend
                    } catch (error) {
                        console.error('Save Metadata Error:', error);
                        setGlobalError(`Save failed: ${error.message}`);
                        return null;
                    }
                };

                const loadRecordings = async () => {
                    globalError.value = null;
                    isLoadingRecordings.value = true;
                    try {
                        const response = await fetch('/recordings');
                        const data = await response.json();
                        if (!response.ok) throw new Error(data.error || 'Failed to load recordings');
                        recordings.value = data;


                        // On load, check for any recordings stuck in PENDING, PROCESSING, or SUMMARIZING
                        // and ensure polling is active if the queue processor isn't running.
                        const incompleteRecordings = recordings.value.filter(r => ['PENDING', 'PROCESSING', 'SUMMARIZING'].includes(r.status));

                        if (incompleteRecordings.length > 0 && !isProcessingActive.value) {
                            console.warn(`Found ${incompleteRecordings.length} incomplete recording(s) on load. Attempting to resume polling if not already queued.`);
                            for (const recording of incompleteRecordings) {
                                // Is this item already being tracked in the queue?
                                let queueItem = uploadQueue.value.find(item => item.recordingId === recording.id);
                                if (!queueItem) {
                                    // If not in queue (likely page reload), create a placeholder to track polling
                                    console.log(`Re-attaching poll for recording ${recording.id}.`);
                                    queueItem = {
                                        // Mock file object, size might be useful for display
                                        file: { name: recording.title || `Recording ${recording.id}`, size: recording.file_size },
                                        status: recording.status, // Use current status from DB
                                        recordingId: recording.id,
                                        clientId: `reload-${recording.id}`, // Unique ID for tracking
                                        error: null
                                    };
                                    // Add to the *beginning* of the visual queue *if* we want to show it there
                                    // Or just manage polling without adding to queue visually?
                                    // Let's add it to the queue for consistency in management.
                                    uploadQueue.value.unshift(queueItem);
                                    // Start processing queue if it wasn't active
                                    if (!isProcessingActive.value) {
                                        startProcessingQueue();
                                    } else if (currentlyProcessingFile.value?.recordingId !== recording.id) {
                                        // If processor is active but on a different file, just ensure polling starts
                                        // Note: startProcessingQueue handles finding the next 'queued'. This item
                                        // might not be 'queued'. We need direct polling.
                                        // Let's rethink: The queue processor should handle finding PENDING/PROCESSING items.
                                        // For simplicity, let's just trigger the queue processor. It will find this item if it's next.
                                        // If something else is truly processing, this won't interrupt.
                                        console.log("Triggering queue processor check due to reloaded incomplete item.")
                                        // Ensure it's marked conceptually 'queued' for the processor to pick up
                                        queueItem.status = 'queued';
                                        startProcessingQueue(); // Let the queue logic handle it
                                    }

                                } else if (queueItem.status !== recording.status && !['completed', 'failed'].includes(queueItem.status)) {
                                    // If queue status differs from DB, update queue status
                                    console.log(`Correcting queue status for ${queueItem.clientId} from ${queueItem.status} to ${recording.status}`);
                                    queueItem.status = recording.status;
                                    // Restart queue processing if needed
                                    if (!isProcessingActive.value) startProcessingQueue();
                                }
                            }
                        }

                    } catch (error) {
                        console.error('Load Recordings Error:', error);
                        setGlobalError(`Failed to load recordings: ${error.message}`);
                        recordings.value = [];
                    } finally {
                        isLoadingRecordings.value = false;
                    }
                };

                 const selectRecording = (recording) => {
                     selectedRecording.value = recording;
                     // Optional: Check if polling needs to be restarted if user selects an incomplete item
                     // This logic is complex and might be redundant with the loadRecordings check.
                     // Let's rely on loadRecordings and the queue processor for robustness.
                 };

                const editRecording = (recording) => {
                     // Create a deep copy for the modal to prevent modifying original object directly
                    editingRecording.value = JSON.parse(JSON.stringify(recording));
                    showEditModal.value = true;
                };

                const cancelEdit = () => {
                    showEditModal.value = false;
                    editingRecording.value = null;
                };

                 const saveEdit = async () => {
                    // Save using the saveMetadata function which updates the main list & selected item
                     const success = await saveMetadata(editingRecording.value);
                    if (success) {
                        cancelEdit(); // Close modal on success
                     }
                     // Keep modal open on failure, error shown via globalError
                };

                const confirmDelete = (recording) => {
                    recordingToDelete.value = recording;
                    showDeleteModal.value = true;
                };

                const cancelDelete = () => {
                    showDeleteModal.value = false;
                    recordingToDelete.value = null;
                };

                const deleteRecording = async () => {
                    globalError.value = null;
                    if (!recordingToDelete.value) return;
                    const idToDelete = recordingToDelete.value.id;
                    const titleToDelete = recordingToDelete.value.title; // For logging/messaging
                    try {
                        const response = await fetch(`/recording/${idToDelete}`, { method: 'DELETE' });
                        const data = await response.json();
                        if (!response.ok) throw new Error(data.error || 'Failed to delete recording');

                         // Remove from gallery list
                        recordings.value = recordings.value.filter(r => r.id !== idToDelete);

                        // Find and remove from upload queue
                        const queueIndex = uploadQueue.value.findIndex(item => item.recordingId === idToDelete);
                         if (queueIndex !== -1) {
                            const deletedItem = uploadQueue.value.splice(queueIndex, 1)[0];
                             console.log(`Removed item ${deletedItem.clientId} from queue.`);
                             // If deleting the file currently being processed, stop polling and move to next
                            if (currentlyProcessingFile.value?.clientId === deletedItem.clientId) {
                                console.log(`Deleting currently processing file: ${titleToDelete}. Stopping poll and moving to next.`);
                                clearInterval(pollInterval.value); // Stop polling explicitly
                                pollInterval.value = null;
                                resetCurrentFileProcessingState();
                                isProcessingActive.value = false; // Allow queue to restart
                                await nextTick();
                                startProcessingQueue();
                            }
                        }

                        if (selectedRecording.value?.id === idToDelete) selectedRecording.value = null;
                        cancelDelete();
                        console.log(`Successfully deleted recording ${idToDelete} (${titleToDelete})`);

                    } catch (error) {
                        console.error('Delete Error:', error);
                        setGlobalError(`Failed to delete recording "${titleToDelete}": ${error.message}`);
                        cancelDelete(); // Still close modal on error
                    }
                };
                
                // Inline editing methods
                const toggleEditParticipants = () => {
                    editingParticipants.value = !editingParticipants.value;
                    if (!editingParticipants.value) {
                        saveInlineEdit('participants');
                    }
                };
                
                const toggleEditMeetingDate = () => {
                    editingMeetingDate.value = !editingMeetingDate.value;
                    if (!editingMeetingDate.value) {
                        saveInlineEdit('meeting_date');
                    }
                };
                
                const toggleEditSummary = () => {
                    editingSummary.value = !editingSummary.value;
                    if (!editingSummary.value) {
                        saveInlineEdit('summary');
                    }
                };
                
                const toggleEditNotes = () => {
                    editingNotes.value = !editingNotes.value;
                    if (!editingNotes.value) {
                        saveInlineEdit('notes');
                    }
                };
                
                const saveInlineEdit = async (field) => {
                    if (!selectedRecording.value) return;
                    
                    // Create a payload with just the field being edited
                    const payload = {
                        id: selectedRecording.value.id,
                        [field]: selectedRecording.value[field]
                    };
                    
                    // For completeness, include all editable fields in the payload
                    // This ensures the backend has all the data it needs
                    const fullPayload = {
                        id: selectedRecording.value.id,
                        title: selectedRecording.value.title,
                        participants: selectedRecording.value.participants,
                        notes: selectedRecording.value.notes,
                        summary: selectedRecording.value.summary,
                        meeting_date: selectedRecording.value.meeting_date
                    };
                    
                    try {
                        const updatedRecording = await saveMetadata(fullPayload);
                        if (updatedRecording) {
                            // Update the HTML versions from the response
                            if (field === 'notes') {
                                selectedRecording.value.notes_html = updatedRecording.notes_html;
                            } else if (field === 'summary') {
                                selectedRecording.value.summary_html = updatedRecording.summary_html;
                            }
                            
                            // Reset the editing state for the field
                            switch(field) {
                                case 'participants':
                                    editingParticipants.value = false;
                                    break;
                                case 'meeting_date':
                                    editingMeetingDate.value = false;
                                    break;
                                case 'summary':
                                    editingSummary.value = false;
                                    break;
                                case 'notes':
                                    editingNotes.value = false;
                                    break;
                            }
                            showToast(`${field.charAt(0).toUpperCase() + field.slice(1).replace('_', ' ')} updated successfully`);
                        }
                    } catch (error) {
                        console.error(`Save ${field} Error:`, error);
                        setGlobalError(`Failed to save ${field}: ${error.message}`);
                    }
                };

                // --- Lifecycle Hooks ---
                onMounted(() => {
                    loadRecordings();
                    initializeDarkMode(); // Initialize dark mode on load
                });

                // --- Watchers ---
                 watch(uploadQueue, (newQueue, oldQueue) => {
                    if (newQueue.length === 0 && oldQueue.length > 0 && !isProcessingActive.value) {
                        console.log("Upload queue processing finished.");
                        // Auto-minimize after delay
                        setTimeout(() => progressPopupMinimized.value = true, 1000);
                        // Auto-hide popup after all uploads are complete
                        setTimeout(() => {
                            if (completedInQueue.value === totalInQueue.value && !isProcessingActive.value) {
                                progressPopupClosed.value = true;
                            }
                        }, 5000);
                     }
                 }, { deep: true });


                // --- Chat functionality ---
                const showChat = ref(false);
                const chatMessages = ref([]);
                const chatInput = ref('');
                const isChatLoading = ref(false);
                
                // Create a ref for the chat messages container
                const chatMessagesRef = ref(null);
                
                const sendChatMessage = async () => {
                    if (!chatInput.value.trim() || isChatLoading.value || !selectedRecording.value || selectedRecording.value.status !== 'COMPLETED') {
                        return;
                    }
                    
                    const message = chatInput.value.trim();

                    // Ensure chatMessages.value is an array before pushing
                    if (!Array.isArray(chatMessages.value)) {
                        console.warn('chatMessages.value was not an array! Resetting. Value was:', chatMessages.value);
                        chatMessages.value = []; // Reset if corrupted
                    }

                    chatMessages.value.push({ role: 'user', content: message });
                    chatInput.value = '';
                    isChatLoading.value = true;
                    
                    // Scroll to bottom of chat
                    await nextTick();
                    // Use the correctly named ref
                    if (chatMessagesRef.value) { 
                        chatMessagesRef.value.scrollTop = chatMessagesRef.value.scrollHeight;
                    }
                    
                    try {
                        // Prepare message history for the API call
                        // We need to convert our UI messages to the format expected by the API
                        const messageHistory = chatMessages.value
                            .slice(0, -1) // Exclude the message we just added (it will be sent separately)
                            .map(msg => ({
                                role: msg.role,
                                content: msg.content
                            }));
                        
                        const response = await fetch('/chat', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                recording_id: selectedRecording.value.id,
                                message: message,
                                message_history: messageHistory
                            })
                        });
                        
                        const data = await response.json();
                        if (!response.ok) throw new Error(data.error || 'Failed to get chat response');
                        
                        chatMessages.value.push({ 
                            role: 'assistant', 
                            content: data.response,
                            html: data.response_html 
                        });
                    } catch (error) {
                        console.error('Chat Error:', error);
                        setGlobalError(`Chat error: ${error.message}`);
                        chatMessages.value.push({ role: 'assistant', content: `Error: ${error.message}` });
                    } finally {
                        isChatLoading.value = false;
                        // Scroll to bottom of chat
                        await nextTick();
                         // Use the correctly named ref
                        if (chatMessagesRef.value) {
                            chatMessagesRef.value.scrollTop = chatMessagesRef.value.scrollHeight;
                        }
                    }
                };
                
                // Toast notification system
                const showToast = (message, icon = 'fa-check-circle', duration = 2000) => {
                    const toastContainer = document.getElementById('toastContainer');
                    
                    // Create toast element
                    const toast = document.createElement('div');
                    toast.className = 'toast';
                    toast.innerHTML = `<i class="fas ${icon}"></i> ${message}`;
                    
                    // Add to container
                    toastContainer.appendChild(toast);
                    
                    // Trigger animation
                    setTimeout(() => {
                        toast.classList.add('show');
                    }, 10);
                    
                    // Remove after duration
                    setTimeout(() => {
                        toast.classList.remove('show');
                        setTimeout(() => {
                            toastContainer.removeChild(toast);
                        }, 300);
                    }, duration);
                };
                
                // Add animation to copy button
                const animateCopyButton = (button) => {
                    button.classList.add('copy-success');
                    
                    // Store original content
                    const originalContent = button.innerHTML;
                    button.innerHTML = '<i class="fas fa-check"></i>';
                    
                    setTimeout(() => {
                        button.classList.remove('copy-success');
                        button.innerHTML = originalContent;
                    }, 1500);
                };
                
                const copyMessage = (text, event) => {
                    // Get the button that was clicked
                    const button = event.currentTarget;
                    
                    if (navigator.clipboard && window.isSecureContext) {
                        // Use clipboard API if available (secure context)
                        navigator.clipboard.writeText(text)
                            .then(() => {
                                showToast('Copied to clipboard!');
                                animateCopyButton(button);
                            })
                            .catch(err => {
                                console.error('Copy failed:', err);
                                showToast('Failed to copy: ' + err.message, 'fa-exclamation-circle');
                                fallbackCopyTextToClipboard(text, button);
                            });
                    } else {
                        // Fallback for non-secure contexts
                        fallbackCopyTextToClipboard(text, button);
                    }
                };
                
                // Fallback method using document.execCommand
                const fallbackCopyTextToClipboard = (text, button = null) => {
                    try {
                        const textArea = document.createElement("textarea");
                        textArea.value = text;
                        
                        // Make the textarea out of viewport
                        textArea.style.position = "fixed";
                        textArea.style.left = "-999999px";
                        textArea.style.top = "-999999px";
                        document.body.appendChild(textArea);
                        
                        // Select and copy
                        textArea.focus();
                        textArea.select();
                        const successful = document.execCommand('copy');
                        
                        // Clean up
                        document.body.removeChild(textArea);
                        
                        if (successful) {
                            showToast('Copied to clipboard!');
                            if (button) animateCopyButton(button);
                        } else {
                            showToast('Copy failed. Your browser may not support this feature.', 'fa-exclamation-circle');
                        }
                    } catch (err) {
                        console.error('Fallback copy failed:', err);
                        showToast('Unable to copy: ' + err.message, 'fa-exclamation-circle');
                    }
                };
                
                const copyTranscription = (event) => {
                    if (!selectedRecording.value || !selectedRecording.value.transcription) {
                        showToast('No transcription available to copy.', 'fa-exclamation-circle');
                        return;
                    }
                    
                    // Get the button that was clicked
                    const button = event.currentTarget;
                    
                    // Show visual feedback on button
                    animateCopyButton(button);
                    
                    if (navigator.clipboard && window.isSecureContext) {
                        // Use clipboard API if available (secure context)
                        navigator.clipboard.writeText(selectedRecording.value.transcription)
                            .then(() => {
                                showToast('Transcription copied to clipboard!');
                            })
                            .catch(err => {
                                console.error('Copy failed:', err);
                                showToast('Failed to copy: ' + err.message, 'fa-exclamation-circle');
                                fallbackCopyTextToClipboard(selectedRecording.value.transcription);
                            });
                    } else {
                        // Fallback for non-secure contexts
                        fallbackCopyTextToClipboard(selectedRecording.value.transcription);
                    }
                };
                
                // Clear chat messages when recording changes
                watch(selectedRecording, (newVal) => {
                    chatMessages.value = [];
                    showChat.value = false;
                    selectedTab.value = 'summary'; // Reset tab when recording changes
                });

                return {
                    // State
                    currentView, dragover, recordings, selectedRecording, // currentRecording removed
                    showEditModal, showDeleteModal, editingRecording, recordingToDelete,
                    isLoadingRecordings, globalError, maxFileSizeMB, isDarkMode, // <-- Added isDarkMode
                    // Multi-upload State
                    uploadQueue, currentlyProcessingFile, processingProgress, processingMessage,
                    isProcessingActive, progressPopupMinimized, progressPopupClosed,
                    // Chat State
                    showChat, chatMessages, chatInput, isChatLoading, chatMessagesRef, // <-- Added chatMessagesRef
                    // Computed
                    groupedRecordings, totalInQueue, completedInQueue, queuedFiles, finishedFilesInQueue,
                    // Inline editing state
                    editingParticipants, editingMeetingDate, editingSummary, editingNotes,
                    // Methods
                    handleDrop, handleFileSelect, /*autoSave removed*/ loadRecordings, selectedTab, // <-- Added selectedTab
                    selectRecording, editRecording, cancelEdit, saveEdit, confirmDelete,
                    cancelDelete, deleteRecording, switchToUploadView, switchToGalleryView,
                    formatFileSize, setGlobalError, handleDragLeave, formatStatus, getStatusClass,
                    formatDisplayDate, // <-- ADDED: Expose date formatting function
                    toggleDarkMode, // <-- Added toggleDarkMode
                    toggleSidebar, isSidebarCollapsed, // <-- Added sidebar state and function
                    // Inbox and Highlight methods
                    toggleInbox, toggleHighlight,
                    // Inline editing methods
                    toggleEditParticipants, toggleEditMeetingDate, toggleEditSummary, toggleEditNotes, saveInlineEdit,
                    // Chat Methods
                    sendChatMessage, copyMessage, copyTranscription,
                    // User menu
                    isUserMenuOpen,
                 }
            },
            delimiters: ['${', '}'] // Keep Vue delimiters distinct from Flask's Jinja
        }).mount('#app');
    </script>
{% endraw %}
</body>
</html>
